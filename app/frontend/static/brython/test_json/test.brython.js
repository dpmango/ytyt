__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1621066454212, "jsonpath": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import print_function\n\n__author__=\"Phil Budne\"\n__revision__=\"$Revision: 1.17 $\"\n__version__='0.82'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport re\nimport sys\n\n\n\n\n\n\n\n\n\n\n\n__all__=['jsonpath']\n\n\n\n\n\n\nif sys.version_info[0]==3:\n xrange=range\n \n \ndef normalize(x):\n ''\n subx=[]\n \n \n \n def f1(m):\n  n=len(subx)\n  g1=m.group(1)\n  subx.append(g1)\n  ret=\"[#%d]\"%n\n  \n  return ret\n x=re.sub(r\"[\\['](\\??\\(.*?\\))[\\]']\",f1,x)\n \n \n x=re.sub(r\"'?(?<!@)\\.'?|\\['?\",\";\",x)\n \n x=re.sub(r\";;;|;;\",\";..;\",x)\n \n x=re.sub(r\";$|'?\\]|'$\",\"\",x)\n \n \n def f2(m):\n  g1=m.group(1)\n  \n  return subx[int(g1)]\n  \n x=re.sub(r\"#([0-9]+)\",f2,x)\n \n return x\n \ndef jsonpath(obj,expr,result_type='VALUE',debug=0,use_eval=True ):\n ''\n \n def s(x,y):\n  ''\n  return str(x)+';'+str(y)\n  \n def isint(x):\n  ''\n  return x.isdigit()\n  \n def as_path(path):\n  ''\n  \n  p='$'\n  for piece in path.split(';')[1:]:\n  \n  \n   if isint(piece):\n    p +=\"[%s]\"%piece\n   else :\n    p +=\"['%s']\"%piece\n  return p\n  \n def store(path,object):\n  if result_type =='VALUE':\n   result.append(object)\n  elif result_type =='IPATH':\n  \n   result.append(path.split(';')[1:])\n  else :\n   result.append(as_path(path))\n  return path\n  \n def trace(expr,obj,path):\n  if debug:print(\"trace\",expr,\"/\",path)\n  if expr:\n   x=expr.split(';')\n   loc=x[0]\n   x=';'.join(x[1:])\n   if debug:print(\"\\t\",loc,type(obj))\n   if loc ==\"*\":\n    def f03(key,loc,expr,obj,path):\n     if debug >1:print(\"\\tf03\",key,loc,expr,path)\n     trace(s(key,expr),obj,path)\n    walk(loc,x,obj,path,f03)\n   elif loc ==\"..\":\n    trace(x,obj,path)\n    def f04(key,loc,expr,obj,path):\n     if debug >1:print(\"\\tf04\",key,loc,expr,path)\n     if isinstance(obj,dict):\n      if key in obj:\n       trace(s('..',expr),obj[key],s(path,key))\n     else :\n      if key <len(obj):\n       trace(s('..',expr),obj[key],s(path,key))\n    walk(loc,x,obj,path,f04)\n   elif loc ==\"!\":\n   \n    def f06(key,loc,expr,obj,path):\n     if isinstance(obj,dict):\n      trace(expr,key,path)\n    walk(loc,x,obj,path,f06)\n   elif isinstance(obj,dict)and loc in obj:\n    trace(x,obj[loc],s(path,loc))\n   elif isinstance(obj,list)and isint(loc):\n    iloc=int(loc)\n    if debug:print(\"----->\",iloc,len(obj))\n    if len(obj)>iloc:\n     trace(x,obj[iloc],s(path,loc))\n   else :\n   \n    if loc.startswith(\"(\")and loc.endswith(\")\"):\n     if debug >1:print(\"index\",loc)\n     e=evalx(loc,obj)\n     trace(s(e,x),obj,path)\n     return\n     \n     \n    if loc.startswith(\"?(\")and loc.endswith(\")\"):\n     if debug >1:print(\"filter\",loc)\n     def f05(key,loc,expr,obj,path):\n      if debug >1:print(\"f05\",key,loc,expr,path)\n      if isinstance(obj,dict):\n       eval_result=evalx(loc,obj[key])\n      else :\n       eval_result=evalx(loc,obj[int(key)])\n      if eval_result:\n       trace(s(key,expr),obj,path)\n       \n     loc=loc[2:-1]\n     walk(loc,x,obj,path,f05)\n     return\n     \n    m=re.match(r'(-?[0-9]*):(-?[0-9]*):?(-?[0-9]*)$',loc)\n    if m:\n     if isinstance(obj,(dict,list)):\n      def max(x,y):\n       if x >y:\n        return x\n       return y\n       \n      def min(x,y):\n       if x <y:\n        return x\n       return y\n       \n      objlen=len(obj)\n      s0=m.group(1)\n      s1=m.group(2)\n      s2=m.group(3)\n      \n      \n      start=int(s0)if s0 else 0\n      end=int(s1)if s1 else objlen\n      step=int(s2)if s2 else 1\n      \n      if start <0:\n       start=max(0,start+objlen)\n      else :\n       start=min(objlen,start)\n      if end <0:\n       end=max(0,end+objlen)\n      else :\n       end=min(objlen,end)\n       \n      for i in xrange(start,end,step):\n       trace(s(i,x),obj,path)\n     return\n     \n     \n    if loc.find(\",\")>=0:\n    \n     for piece in re.split(r\"'?,'?\",loc):\n      if debug >1:print(\"piece\",piece)\n      trace(s(piece,x),obj,path)\n  else :\n   store(path,obj)\n   \n def walk(loc,expr,obj,path,funct):\n  if isinstance(obj,list):\n   for i in xrange(0,len(obj)):\n    funct(i,loc,expr,obj,path)\n  elif isinstance(obj,dict):\n   for key in obj:\n    funct(key,loc,expr,obj,path)\n    \n def evalx(loc,obj):\n  ''\n  \n  if debug:print(\"evalx\",loc)\n  \n  \n  \n  loc=loc.replace(\"@.length\",\"len(__obj)\")\n  \n  loc=loc.replace(\"&&\",\" and \").replace(\"||\",\" or \")\n  \n  \n  \n  def notvar(m):\n   return \"'%s' not in __obj\"%m.group(1)\n  loc=re.sub(\"!@\\.([a-zA-Z@_0-9-]*)\",notvar,loc)\n  \n  \n  \n  def varmatch(m):\n   def brackets(elts):\n    ret=\"__obj\"\n    for e in elts:\n     if isint(e):\n      ret +=\"[%s]\"%e\n     else :\n      ret +=\"['%s']\"%e\n    return ret\n   g1=m.group(1)\n   elts=g1.split('.')\n   if elts[-1]==\"length\":\n    return \"len(%s)\"%brackets(elts[1:-1])\n   return brackets(elts[1:])\n   \n  loc=re.sub(r'(?<!\\\\)(@\\.[a-zA-Z@_.0-9]+)',varmatch,loc)\n  \n  \n  \n  \n  \n  loc=re.sub(r'(?<!\\\\)@',\"__obj\",loc).replace(r'\\@','@')\n  if not use_eval:\n   if debug:print(\"eval disabled\")\n   raise Exception(\"eval disabled\")\n  if debug:print(\"eval\",loc)\n  try :\n  \n   v=eval(loc,caller_globals,{'__obj':obj})\n  except Exception as e:\n   if debug:print(repr(e))\n   return False\n   \n  if debug:print(\"->\",v)\n  return v\n  \n  \n  \n  \n caller_globals=sys._getframe(1).f_globals\n result=[]\n if expr and obj:\n  cleaned_expr=normalize(expr)\n  if cleaned_expr.startswith(\"$;\"):\n   cleaned_expr=cleaned_expr[2:]\n   \n   \n  trace(cleaned_expr,obj,'$')\n  \n  if len(result)>0:\n   return result\n return False\n \nif __name__ =='__main__':\n try :\n  import json\n except ImportError:\n  import simplejson as json\n  \n import sys\n \n \n \n if len(sys.argv)<3 or len(sys.argv)>4:\n  sys.stdout.write(\"Usage: jsonpath.py FILE PATH [OUTPUT_TYPE]\\n\")\n  sys.exit(1)\n  \n object=json.load(file(sys.argv[1]))\n path=sys.argv[2]\n format='VALUE'\n \n if len(sys.argv)>3:\n \n  format=sys.argv[3]\n  \n value=jsonpath(object,path,format)\n \n if not value:\n  sys.exit(1)\n  \n f=sys.stdout\n json.dump(value,f,sort_keys=True ,indent=1)\n f.write(\"\\n\")\n \n sys.exit(0)\n", ["__future__", "json", "re", "simplejson", "sys"]]}
__BRYTHON__.update_VFS(scripts)
